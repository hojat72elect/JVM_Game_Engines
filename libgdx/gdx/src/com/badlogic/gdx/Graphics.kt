package com.badlogic.gdx

import com.badlogic.gdx.graphics.Cursor
import com.badlogic.gdx.graphics.Cursor.SystemCursor
import com.badlogic.gdx.graphics.GL20
import com.badlogic.gdx.graphics.GL30
import com.badlogic.gdx.graphics.GL31
import com.badlogic.gdx.graphics.GL32
import com.badlogic.gdx.graphics.Mesh
import com.badlogic.gdx.graphics.Pixmap
import com.badlogic.gdx.graphics.g2d.Batch
import com.badlogic.gdx.graphics.g2d.BitmapFont
import com.badlogic.gdx.graphics.glutils.FrameBuffer
import com.badlogic.gdx.graphics.glutils.GLVersion
import com.badlogic.gdx.graphics.glutils.IndexBufferObject
import com.badlogic.gdx.graphics.glutils.ShaderProgram
import com.badlogic.gdx.graphics.glutils.VertexArray
import com.badlogic.gdx.graphics.glutils.VertexBufferObject

/**
 * This interface encapsulates communication with the graphics processor. Depending on the available hardware and the current
 * [Application] configuration, access to [GL20] and [GL30] are provided here.
 *
 * If supported by the backend, this interface lets you query the available display modes (graphics resolution and color depth)
 * and change it.
 *
 * This interface can be used to switch between continuous and non-continuous rendering (see
 * [setContinuousRendering]), and to explicitly [requestRendering].
 *
 * There are many more utility classes that are not directly generated by the [Graphics] interfaces. See [VertexArray]
 * , [VertexBufferObject], [IndexBufferObject], [Mesh], [ShaderProgram] and [FrameBuffer],
 * [BitmapFont], [Batch] and so on. All these classes are managed, meaning they don't need to be reloaded on a context
 * loss. Explore the `com.badlogic.gdx.graphics` package for more classes that might come in handy.
 */
interface Graphics {
    /**
     * Returns whether OpenGL ES 3.0 is available. If it is you can get an instance of [GL30] via [.getGL30] to
     * access OpenGL ES 3.0 functionality. Note that this functionality will only be available if you instructed the
     * [Application] instance to use OpenGL ES 3.0!
     *
     * @return whether OpenGL ES 3.0 is available
     */
    fun isGL30Available(): Boolean

    /**
     * Returns whether OpenGL ES 3.1 is available. If it is, you can get an instance of [GL31] via [gL31] to
     * access OpenGL ES 3.1 functionality. Note that this functionality will only be available if you instructed the
     * [Application] instance to use OpenGL ES 3.1!
     *
     * @return whether OpenGL ES 3.1 is available.
     */
    fun isGL31Available(): Boolean

    /**
     * Returns whether OpenGL ES 3.2 is available. If it is, you can get an instance of [GL32] via [gL32] to
     * access OpenGL ES 3.2 functionality. Note that this functionality will only be available if you instructed the
     * [Application] instance to use OpenGL ES 3.2!
     *
     * @return whether OpenGL ES 3.2 is available.
     */
    fun isGL32Available(): Boolean

    /**
     * this is the mechanism for setting or getting the [GL20] instance.
     */
    fun getGL20(): GL20?

    fun setGL20(gl20: GL20)

    /**
     * this is the mechanism for setting or getting the [GL30] instance.
     */
    fun getGL30(): GL30?

    fun setGL30(gl30: GL30)

    /**
     * this is the mechanism for setting or getting the [GL31] instance.
     */
    fun getGL31(): GL31?

    fun setGL31(gl31: GL31)

    /**
     * this is the mechanism for setting or getting the [GL32] instance.
     */
    fun getGL32(): GL32?

    fun setGL32(gl32: GL32)

    /**
     * @return the width of the client area in logical pixels.
     */
    fun getWidth(): Int

    /**
     * @return the height of the client area in logical pixels.
     */
    fun getHeight(): Int

    /**
     * @return the width of the framebuffer in physical pixels.
     */
    fun getBackBufferWidth(): Int

    /**
     * @return the height of the framebuffer in physical pixels.
     */
    fun getBackBufferHeight(): Int

    /**
     * @return The amount of pixels per logical pixel (point).
     */
    fun getBackBufferScale(): Float

    /**
     * @return the inset from the left which avoids display cutouts in logical pixels.
     */
    fun getSafeInsetLeft(): Int

    /**
     * @return the inset from the top which avoids display cutouts in logical pixels.
     */
    fun getSafeInsetTop(): Int

    /**
     * @return the inset from the bottom which avoids display cutouts or floating gesture bars, in logical pixels.
     */
    fun getSafeInsetBottom(): Int

    /**
     * @return the inset from the right which avoids display cutouts in logical pixels.
     */
    fun getSafeInsetRight(): Int

    /**
     * Returns the id of the current frame. The general contract of this method is that the id is incremented only when the
     * application is in the running state right before calling the [ApplicationListener.render] method. Also, the id of
     * the first frame is 0; the id of subsequent frames is guaranteed to take increasing values for (2 ^ 63 - 1) rendering
     * cycles.
     *
     * The id of the current frame.
     */
    fun getFrameId(): Long

    /**
     * The time span between the current frame and the last frame in seconds.
     */
    fun getDeltaTime(): Float

    /**
     * @return the time span between the current frame and the last frame in seconds, without smoothing
     */
    @Deprecated("use {@link #getDeltaTime()} instead.")
    fun getRawDeltaTime(): Float

    /**
     * @return the average number of frames per second
     */
    fun getFramesPerSecond(): Int

    /**
     * @return the [GraphicsType] of this Graphics instance
     */
    fun getType(): GraphicsType

    /**
     * @return the [GLVersion] of this Graphics instance
     */
    fun getGLVersion(): GLVersion

    /**
     * @return the pixels per inch on the x-axis
     */
    fun getPpiX(): Float

    /**
     * @return the pixels per inch on the y-axis
     */
    fun getPpiY(): Float

    /**
     * @return the pixels per centimeter on the x-axis
     */
    fun getPpcX(): Float

    /**
     * @return the pixels per centimeter on the y-axis.
     */
    fun getPpcY(): Float

    /**
     * This is a scaling factor for the Density Independent Pixel unit, following the same conventions as
     * android.util.DisplayMetrics#density, where one DIP is one pixel on an approximately 160 dpi screen. Thus on a 160dpi screen
     * this density value will be 1; on a 120 dpi screen it would be .75; etc.
     *
     *
     * If the density could not be determined, this returns a default value of 1.
     *
     *
     * Depending on the underlying platform implementation this might be a relatively expensive operation. Therefore it should not
     * be called continuously on each frame.
     *
     * @return the Density Independent Pixel factor of the display.
     */
    fun getDensity(): Float

    /**
     * Whether the given backend supports a display mode change via calling [Graphics.setFullscreenMode]
     *
     * @return whether display mode changes are supported or not.
     */
    fun supportsDisplayModeChange(): Boolean

    /**
     * @return the primary monitor
     */
    fun getPrimaryMonitor(): Monitor?

    /**
     * @return the monitor the application's window is located on
     */
    fun getMonitor(): Monitor?

    /**
     * @return the currently connected [Monitor]s
     */
    fun getMonitors(): Array<Monitor>?

    /**
     * @return the supported fullscreen [DisplayMode](s) of the monitor the window is on
     */
    fun getDisplayModes(): Array<DisplayMode>

    /**
     * @return the supported fullscreen [DisplayMode]s of the given [Monitor]
     */
    fun getDisplayModes(monitor: Monitor): Array<DisplayMode>?

    /**
     * @return the current [DisplayMode] of the monitor the window is on.
     */
    fun getDisplayMode(): DisplayMode?

    /**
     * @return the current [DisplayMode] of the given [Monitor]
     */
    fun getDisplayMode(monitor: Monitor): DisplayMode?

    /**
     * Sets the window to full-screen mode.
     *
     * @param displayMode the display mode.
     * @return whether the operation succeeded.
     */
    fun setFullscreenMode(displayMode: DisplayMode): Boolean

    /**
     * Sets the window to windowed mode.
     *
     * @param width  the width in pixels
     * @param height the height in pixels
     * @return whether the operation succeeded
     */
    fun setWindowedMode(width: Int, height: Int): Boolean

    /**
     * Sets the title of the window. Ignored on Android.
     *
     * @param title the title.
     */
    fun setTitle(title: String)

    /**
     * Sets the window decoration as enabled or disabled. On Android, this will enable/disable the menu bar.
     *
     *
     * Note that immediate behavior of this method may vary depending on the implementation. It may be necessary for the window to
     * be recreated in order for the changes to take effect. Consult the documentation for the backend in use for more information.
     *
     *
     * Supported on all GDX desktop backends and on Android (to disable the menu bar).
     *
     * @param undecorated true if the window border or status bar should be hidden. false otherwise.
     */
    fun setUndecorated(undecorated: Boolean)

    /**
     * Sets whether or not the window should be resizable. Ignored on Android.
     *
     *
     * Note that immediate behavior of this method may vary depending on the implementation. It may be necessary for the window to
     * be recreated in order for the changes to take effect. Consult the documentation for the backend in use for more information.
     *
     *
     * Supported on all GDX desktop backends.
     */
    fun setResizable(resizable: Boolean)

    /**
     * Enable/Disable vsynching. This is a best-effort attempt which might not work on all platforms.
     *
     * @param vsync vsync enabled or not.
     */
    fun setVSync(vsync: Boolean)

    /**
     * Sets the target framerate for the application when using continuous rendering. Might not work on all platforms. Is not
     * generally advised to be used on mobile platforms.
     *
     * @param fps the targeted fps; default differs by platform
     */
    fun setForegroundFPS(fps: Int)

    /**
     * @return the format of the color, depth and stencil buffer in a [BufferFormat] instance
     */
    fun getBufferFormat(): BufferFormat?

    /**
     * @param extension the extension name
     * @return whether the extension is supported
     */
    fun supportsExtension(extension: String): Boolean

    /**
     * @return whether rendering is continuous.
     */
    fun isContinuousRendering(): Boolean

    /**
     * Sets whether to render continuously. In the case that rendering is performed non-continuously, the following events will trigger a
     * re-draw:
     *
     *  1- A call to [requestRendering]
     *  2- Input events from the touch screen/mouse or keyboard
     *  3- A [Runnable] is posted to the rendering thread via [Application.postRunnable]. In the case of a
     * multi-window app, all windows will request rendering if a runnable is posted to the application. To avoid this, post a
     * runnable to the window instead.
     *
     * Life-cycle events will also be reported as usual, see [ApplicationListener]. This method can be called from any
     * thread.
     *
     * @param isContinuous whether the rendering should be continuous or not.
     */
    fun setContinuousRendering(isContinuous: Boolean)

    /**
     * Requests a new frame to be rendered if the rendering mode is non-continuous. This method can be called from any thread.
     */
    fun requestRendering()

    /**
     * Whether the app is fullscreen or not
     */
    fun isFullscreen(): Boolean

    /**
     * Create a new cursor represented by the [Pixmap]. The Pixmap must be in RGBA8888 format,
     * width & height must be powers-of-two greater than zero (not necessarily equal) and of a certain minimum size (32x32 is a
     * safe bet), and alpha transparency must be single-bit (i.e., 0x00 or 0xFF only). This function returns a Cursor object that
     * can be set as the system cursor by calling [.setCursor] .
     *
     * @param pixmap   the mouse cursor image as a [Pixmap]
     * @param xHotspot the x location of the hotspot pixel within the cursor image (origin top-left corner)
     * @param yHotspot the y location of the hotspot pixel within the cursor image (origin top-left corner)
     * @return a cursor object that can be used by calling [setCursor] or null if not supported
     */
    fun newCursor(pixmap: Pixmap, xHotspot: Int, yHotspot: Int): Cursor?

    /**
     * Only viable on the lwjgl-backend and on the gwt-backend. Browsers that support cursor:url() and support the png format (the
     * pixmap is converted to a data-url of type image/png) should also support custom cursors. Will set the mouse cursor image to
     * the image represented by the [Cursor]. It is recommended to call this function in the main
     * render thread, and maximum one time per frame.
     *
     * @param cursor the mouse cursor as a [Cursor]
     */
    fun setCursor(cursor: Cursor)

    /**
     * Sets one of the predefined [SystemCursor]s
     */
    fun setSystemCursor(systemCursor: SystemCursor)

    /**
     * Enumeration describing different types of [Graphics] implementations.
     */
    enum class GraphicsType {
        AndroidGL, LWJGL, WebGL, iOSGL, JGLFW, Mock, LWJGL3
    }

    /**
     * Describe a fullscreen display mode.
     *
     * @param width the width in physical pixels.
     * @param height the height in physical pixels
     * @param refreshRate the refresh rate in Hertz
     * @param bitsPerPixel the number of bits per pixel, may exclude alpha
     */
    open class DisplayMode(@JvmField val width: Int, @JvmField val height: Int, @JvmField val refreshRate: Int, @JvmField val bitsPerPixel: Int) {
        override fun toString(): String {
            return width.toString() + "x" + height + ", bpp: " + bitsPerPixel + ", hz: " + refreshRate
        }
    }

    /**
     * Describes a monitor
     */
    open class Monitor(@JvmField val virtualX: Int, @JvmField val virtualY: Int, val name: String)

    /**
     * Class describing the bits per pixel, depth buffer precision, stencil precision and number of MSAA samples.
     *
     * @params r, g, b, a : number of bits per color channel.
     * @params depth, stencil : number of bits for depth and stencil buffer
     * @param samples number of samples for multi-sample anti-aliasing (MSAA)
     * @param coverageSampling whether coverage sampling anti-aliasing is used. in that case you have to clear the coverage buffer as well!
     */
    class BufferFormat(val r: Int, val g: Int, val b: Int, val a: Int, val depth: Int, val stencil: Int, val samples: Int, val coverageSampling: Boolean) {
        override fun toString(): String {
            return ("r: " + r + ", g: " + g + ", b: " + b + ", a: " + a + ", depth: " + depth + ", stencil: " + stencil
                    + ", num samples: " + samples + ", coverage sampling: " + coverageSampling)
        }
    }
}
