/*
 * Copyright 2020-2021 Anton Trushkov
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package app.thelema.ui

import app.thelema.app.APP
import app.thelema.app.Cursor
import app.thelema.font.BitmapFont
import app.thelema.font.GlyphLayout
import app.thelema.g2d.Batch
import app.thelema.input.KEY
import app.thelema.math.IVec2
import app.thelema.math.Vec2
import app.thelema.ui.TextField.OnscreenKeyboard
import app.thelema.utils.Color
import kotlin.math.abs
import kotlin.math.max
import kotlin.math.min
import kotlin.math.roundToLong


/** A single-line text input field.
 *
 *
 * The preferred height of a text field is the height of the [ButtonStyle.font] and [ButtonStyle.background].
 * The preferred width of a text field is 150, a relatively arbitrary size.
 *
 *
 * The text field will copy the currently selected text when ctrl+c is pressed, and paste any text in the clipboard when ctrl+v is
 * pressed. Currently there are two standard
 * implementations, one for the desktop and one for Android. The Android clipboard is a stub, as copy & pasting on Android is not
 * supported yet.
 *
 *
 * The text field allows you to specify an [OnscreenKeyboard] for displaying a softkeyboard and piping all key events
 * generated by the keyboard to the text field. There are two standard implementations, one for the desktop and one for Android.
 * The desktop keyboard is a stub, as a softkeyboard is not needed on the desktop. The Android [OnscreenKeyboard]
 * implementation will bring up the default IME.
 * @author mzechner, Nathan Sweet
 */
open class TextField(style: TextFieldStyle = DSKIN.textField) : Widget(), Focusable, BorderOwner {
    constructor(
        style: TextFieldStyle = DSKIN.textField,
        block: TextField.() -> Unit
    ): this(style) {
        block(this)
    }

    protected open var textInternal = ""
        set(value) {
            val oldValue = field
            if (oldValue != value) {
                field = value
                validateInput(value)
            }
        }
    open var text: String
        get() = textInternal
        set(value) {
            if (value == text) return
            val oldText = textInternal
            selectAll()
            paste(value, false)
            clearSelection()
            if (programmaticChangeEvents) changeText(oldText, textInternal)
            cursor = 0
        }

    var isReadOnly = false

    protected var cursor = 0
    var selectionStart = 0
        protected set
    protected var hasSelection = false
    protected var writeEnters = false
    protected val layout = GlyphLayout()
    protected val glyphPositions = ArrayList<Float>()
    var style: TextFieldStyle = style
        set(value) {
            field = value
            value.font.onLoaded {
                textHeight = value.font.capHeight - value.font.descent * 2
                invalidateHierarchy()
            }
        }

    override var isFocusBorderEnabled = true

    /** Sets the text that will be drawn in the text field if no text has been entered.
     * @param messageText may be null.
     */
    var hintText: String? = null
    protected var displayText: CharSequence = ""
    var defaultInputListener: InputListener? = null
    var listener: TextFieldListener? = null
    /** @param filter May be null.
     */
    var textFieldFilter: TextFieldFilter? = null
    /** Default is an instance of [DefaultOnscreenKeyboard].  */
    var onscreenKeyboard: OnscreenKeyboard = DefaultOnscreenKeyboard()

    /** If true (the default), tab/shift+tab will move to the next text field.  */
    var focusTraversal = true

    /** When false, text set by [setText] may contain characters not in the font, a space will be displayed instead.
     * When true (the default), characters not in the font are stripped by setText. Characters not in the font are always stripped
     * when typed or pasted.  */
    var onlyFontChars = true

    var isDisabled: Boolean = false

    /** Sets text horizontal alignment (left, center or right).
     * @see Align
     */
    var alignment = -1
    private var selectionX = 0f
    private var selectionWidth = 0f
    var undoText: String? = ""
    var lastChangeTime: Long = 0
    var passwordMode = false
        set(value) {
            field = value
            updateDisplayText()
        }
    private var passwordBuffer: StringBuilder? = null
    private var passwordCharacter = BULLET
    protected var fontOffset = 0f
    protected var textHeight = 0f
    protected var textOffset = 0f
    var renderOffset = 0f
    private var visibleTextStart = 0
    private var visibleTextEnd = 0
    var maxLength = 0
    var focused = false
    var isCursorOn = false

    /** If false, methods that change the text will not fire [Event],
     * the event will be fired only when user changes the text. */
    var programmaticChangeEvents = true

    private var validationEnabled = true

    private val validators = ArrayList<InputValidator>()

    private val clickListener = object : ClickListener() {
        override fun enter(event: InputEvent, x: Float, y: Float, pointer: Int, fromActor: Actor?) {
            super.enter(event, x, y, pointer, fromActor)
            if (pointer == -1 && !isDisabled) {
                APP.cursor = Cursor.IBeam
            }
        }

        override fun exit(event: InputEvent, x: Float, y: Float, pointer: Int, toActor: Actor?) {
            super.exit(event, x, y, pointer, toActor)
            if (pointer == -1) {
                APP.cursor = APP.defaultCursor
            }
        }
    }

    fun addValidator(validator: InputValidator) {
        validators.add(validator)
        validateInput()
    }

    /** [block] must return true if text is valid */
    fun validate(block: (text: CharSequence) -> Boolean): InputValidator {
        val validator = object : InputValidator {
            override fun validateInput(input: CharSequence): Boolean = block(text)
        }
        addValidator(validator)
        return validator
    }

    fun validateInput(text: String = this.text) {
        if (validationEnabled) {
            for (validator in validators) {
                if (!validator.validateInput(text)) {
                    isInputValid = false
                    return
                }
            }
        }
        // validation not enabled or validators does not returned false (input was valid)
        isInputValid = true
    }

    protected open fun createInputListener(): InputListener {
        return TextFieldClickListener()
    }

    protected open fun letterUnderCursor(x: Float): Int {
        if (glyphPositions.size > 0) {
            var x = x
            x -= textOffset + fontOffset - style.font.cursorX - glyphPositions[visibleTextStart]
            val background = backgroundDrawable
            if (background != null) x -= style.background?.leftWidth ?: 0f
            val n = glyphPositions.size
            for (i in 1 until n) {
                if (glyphPositions[i] > x) {
                    return if (glyphPositions[i] - x <= x - glyphPositions[i - 1]) i else i - 1
                }
            }

            return n - 1
        } else {
            return -1
        }
    }

    protected fun isWordCharacter(c: Char): Boolean = c !in '0'..'9'

    fun withinMaxLength(size: Int): Boolean {
        return maxLength <= 0 || size < maxLength
    }

    protected open fun calculateOffsets() {
        var visibleWidth = width
        val background = backgroundDrawable
        if (background != null) visibleWidth -= background.leftWidth + background.rightWidth
        val glyphCount = glyphPositions.size
        if (glyphCount > 0) {
            // Check if the cursor has gone out the left or right side of the visible area and adjust renderOffset.
            val distance = glyphPositions[max(0, cursor - 1)] + renderOffset
            if (distance <= 0) renderOffset -= distance else {
                val index = min(glyphCount - 1, cursor + 1)
                val minX = glyphPositions[index] - visibleWidth
                if (-renderOffset < minX) renderOffset = -minX
            }
            // Prevent renderOffset from starting too close to the end, eg after text was deleted.
            var maxOffset = 0f
            val width = glyphPositions[glyphCount - 1]
            for (i in glyphCount - 2 downTo 0) {
                val x = glyphPositions[i]
                if (width - x > visibleWidth) break
                maxOffset = x
            }
            if (-renderOffset > maxOffset) renderOffset = -maxOffset

            // calculate first visible char based on render offset
            visibleTextStart = 0
            var startX = 0f
            for (i in 0 until glyphCount) {
                if (glyphPositions[i] >= -renderOffset) {
                    visibleTextStart = i
                    startX = glyphPositions[i]
                    break
                }
            }
            // calculate last visible char based on visible width and render offset
            var end = visibleTextStart + 1
            val endX = visibleWidth - renderOffset
            val n = min(displayText.length, glyphCount)
            while (end <= n) {
                if (glyphPositions[end] > endX) break
                end++
            }
            visibleTextEnd = max(0, end - 1)
            if (alignment >= 0) {
                textOffset = visibleWidth - glyphPositions[visibleTextEnd] - fontOffset + startX
                if (alignment == 0) textOffset = (textOffset * 0.5f).roundToLong().toFloat()
            } else textOffset = startX + renderOffset
            // calculate selection x position and width
            if (hasSelection) {
                val minIndex = min(cursor, selectionStart)
                val maxIndex = max(cursor, selectionStart)
                val minX = max(glyphPositions[minIndex] - glyphPositions[visibleTextStart], -textOffset)
                val maxX = min(glyphPositions[maxIndex] - glyphPositions[visibleTextStart], visibleWidth - textOffset)
                selectionX = minX
                selectionWidth = maxX - minX - style.font.cursorX
            }
        }
    }

    private val backgroundDrawable: Drawable?
        get() {
            val focused = hasKeyboardFocus()
            return if (isDisabled && style.disabledBackground != null) style.disabledBackground else if (focused && style.focusedBackground != null) style.focusedBackground else style.background
        }

    var isInputValid = true

    var textColor: Int? = null

    override fun draw(batch: Batch, parentAlpha: Float) {
        val focused = hasKeyboardFocus()
        if (focused != this.focused) {
            this.focused = focused
            isCursorOn = focused
        } else if (!focused) //
            isCursorOn = false
        val font = style.font

        val selection = style.selection
        val cursorPatch = style.cursor
        var background = backgroundDrawable
        if (!isDisabled && style.backgroundOver != null && (clickListener.isOver || focused)) background = style.backgroundOver
        val color = color
        val x = x
        val y = y
        val width = width
        val height = height
        batch.setMulAlpha(color, parentAlpha)
        var bgLeftWidth = 0f
        var bgRightWidth = 0f
        if (background != null) {
            background.draw(batch, x, y, width, height)
            bgLeftWidth = background.leftWidth
            bgRightWidth = background.rightWidth
        }
        val textY = getTextY(font, background)
        calculateOffsets()
        if (focused && hasSelection && selection != null) {
            drawSelection(selection, batch, font, x + bgLeftWidth, y + textY)
        }
        val yOffset: Float = if (font.isFlipped) -textHeight else 0f
        if (displayText.isEmpty()) {
            if (!focused && hintText != null) {
                val messageFont = if (style.messageFont != null) style.messageFont else font
                if (style.messageFontColor != null) {
                    messageFont!!.color = Color.mulAlpha(style.messageFontColor!!, Color.getAlpha(color) * parentAlpha)
                } else {
                    messageFont!!.color = Color.mulAlpha(Color.LIGHT_GRAY, Color.getAlpha(color) * parentAlpha)
                }
                drawMessageText(batch, messageFont, x + bgLeftWidth, y + textY + yOffset, width - bgLeftWidth - bgRightWidth)
            }
        } else {
            var textColorInternal = -1
            val fontColor = if (isDisabled && style.disabledFontColor != null) {
                style.disabledFontColor
            } else if (focused && style.focusedFontColor != null) {
                style.focusedFontColor
            } else {
                style.fontColor
            }

            if (fontColor != null) {
                textColorInternal = fontColor
            }

            val textColor = textColor
            if (textColor != null) {
                textColorInternal = textColor
            }

            font.color = Color.mulAlpha(textColorInternal, Color.getAlpha(color) * parentAlpha)
            drawText(batch, font, x + bgLeftWidth, y + textY + yOffset)
        }
        if (!isDisabled && isCursorOn && cursorPatch != null) {
            drawCursor(cursorPatch, batch, font, x + bgLeftWidth, y + textY)
        }

        if (!isDisabled && !isInputValid && style.errorBorder != null) {
            style.errorBorder!!.draw(batch, this.x, this.y, width, height)
        } else if (isFocusBorderEnabled && focused) {
            style.focusBorder?.draw(batch, this.x, this.y, width, height)
        }
    }

    protected open fun getTextY(font: BitmapFont?, background: Drawable?): Float {
        val height = height
        var textY = textHeight / 2 + font!!.descent
        textY = if (background != null) {
            val bottom = background.bottomHeight
            textY + (height - background.topHeight - bottom) / 2 + bottom
        } else {
            textY + height / 2
        }
        if (font.usesIntegerPositions()) textY = textY.toInt().toFloat()
        return textY
    }

    /** Draws selection rectangle  */
    protected open fun drawSelection(selection: Drawable, batch: Batch, font: BitmapFont, x: Float, y: Float) {
        selection.draw(batch, x + textOffset + selectionX + fontOffset, y - textHeight - font.descent, selectionWidth,
                textHeight)
    }

    protected open fun drawText(batch: Batch, font: BitmapFont, x: Float, y: Float) {
        font.draw(batch, displayText, x + textOffset, y, visibleTextStart, visibleTextEnd, 0f, -1, false)
    }

    protected fun drawMessageText(batch: Batch, font: BitmapFont, x: Float, y: Float, maxWidth: Float) {
        font.draw(batch, hintText!!, x, y, 0, hintText!!.length, maxWidth, alignment, false, "...")
    }

    protected open fun drawCursor(cursorPatch: Drawable, batch: Batch, font: BitmapFont, x: Float, y: Float) {
        if (glyphPositions.size > 0) {
            cursorPatch.draw(batch,
                    x + textOffset + glyphPositions[cursor] - glyphPositions[visibleTextStart] + fontOffset + font.cursorX,
                    y - textHeight - font.descent, cursorPatch.minWidth, textHeight)
        }
    }

    fun updateDisplayText() {
        val font = style.font
        val text = textInternal
        val textLength = text.length
        val buffer = StringBuilder()
        for (i in 0 until textLength) {
            val c = text[i]
            buffer.append(if (font.hasGlyph(c)) c else ' ')
        }
        val newDisplayText = buffer.toString()
        if (passwordMode && font.hasGlyph(passwordCharacter)) {
            if (passwordBuffer == null) passwordBuffer = StringBuilder(newDisplayText.length)
            if (passwordBuffer!!.length > textLength) passwordBuffer!!.setLength(textLength) else {
                for (i in passwordBuffer!!.length until textLength) passwordBuffer!!.append(passwordCharacter)
            }
            displayText = passwordBuffer!!
        } else displayText = newDisplayText
        layout.setText(font, displayText.toString().replace('\r', ' ').replace('\n', ' '))
        glyphPositions.clear()
        var x = 0f
        if (layout.runs.size > 0) {
            val run = layout.runs.first()
            val xAdvances = run.xAdvances
            fontOffset = xAdvances.first()
            var i = 1
            val n = xAdvances.size
            while (i < n) {
                glyphPositions.add(x)
                x += xAdvances[i]
                i++
            }
        } else fontOffset = 0f
        glyphPositions.add(x)
        visibleTextStart = min(visibleTextStart, glyphPositions.size - 1)
        visibleTextEnd = max(visibleTextStart, min(visibleTextEnd, glyphPositions.size - 1))
        if (selectionStart > newDisplayText.length) selectionStart = textLength
    }

    /** Copies the contents of this TextField to the clipboard  */
    fun copy() {
        if (hasSelection && !passwordMode) {
            APP.clipboardString = textInternal.substring(min(cursor, selectionStart), max(cursor, selectionStart))
        }
    }

    /** Copies the selected contents of this TextField to the clipboard, then removes it.  */
    fun cut() {
        cut(programmaticChangeEvents)
    }

    fun cut(fireChangeEvent: Boolean) {
        if (hasSelection && !passwordMode) {
            copy()
            cursor = delete(fireChangeEvent)
            updateDisplayText()
        }
    }

    fun paste(content: String, fireChangeEvent: Boolean) {
        if (isReadOnly) return
        var content = content
        val buffer = StringBuilder()
        var textLength = textInternal.length
        if (hasSelection) textLength -= abs(cursor - selectionStart)
        val font = style.font
        var i = 0
        val n = content.length
        while (i < n) {
            if (!withinMaxLength(textLength + buffer.length)) break
            val c = content[i]
            if (!(writeEnters && (c == ENTER_ANDROID || c == ENTER_DESKTOP))) {
                if (c == '\r' || c == '\n') {
                    i++
                    continue
                }
                if (onlyFontChars && !font.hasGlyph(c)) {
                    i++
                    continue
                }
                if (textFieldFilter != null && !textFieldFilter!!.acceptChar(this, c)) {
                    i++
                    continue
                }
            }
            buffer.append(c)
            i++
        }
        content = buffer.toString()
        if (hasSelection) cursor = delete(fireChangeEvent)
        if (fireChangeEvent) {
            changeText(textInternal, insert(cursor, content, textInternal))
        } else {
            textInternal = insert(cursor, content, textInternal)
        }
        updateDisplayText()
        cursor += content.length
    }

    fun insert(position: Int, text: CharSequence, to: String): String {
        return if (to.isEmpty()) text.toString() else to.substring(0, position) + text + to.substring(position, to.length)
    }

    fun delete(fireChangeEvent: Boolean): Int {
        val from = selectionStart
        val to = cursor
        val minIndex = min(from, to)
        val maxIndex = max(from, to)
        val newText = ((if (minIndex > 0) textInternal.substring(0, minIndex) else "")
                + if (maxIndex < textInternal.length) textInternal.substring(maxIndex, textInternal.length) else "")
        if (fireChangeEvent) changeText(textInternal, newText) else textInternal = newText
        clearSelection()
        return minIndex
    }

    /** Focuses the next TextField. If none is found, the keyboard is hidden. Does nothing if the text field is not in a stage.
     * @param up If true, the TextField with the same or next smallest y coordinate is found, else the next highest.
     */
    fun next(up: Boolean) {
        val stage = hud ?: return
        var current = this
        val currentCoords = current.parent!!.localToStageCoordinates(tmp2.set(current.x, current.y))
        val bestCoords = tmp1
        while (true) {
            var textField = current.findNextTextField(stage.actors, null, bestCoords, currentCoords, up)
            if (textField == null) { // Try to wrap around.
                if (up) currentCoords.set(-Float.MAX_VALUE, -Float.MAX_VALUE) else currentCoords.set(Float.MAX_VALUE, Float.MAX_VALUE)
                textField = current.findNextTextField(stage.actors, null, bestCoords, currentCoords, up)
            }
            if (textField == null) {
                //Gdx.input.setOnscreenKeyboardVisible(false)
                break
            }
            if (stage.setKeyboardFocus(textField)) {
                textField.selectAll()
                break
            }
            current = textField
            textField.focusField()
            currentCoords.set(bestCoords)
        }
    }

    /** Focuses this field, field must be added to stage before this method can be called  */
    fun focusField() {
        if (isDisabled) return
        val stage = hud
        FocusManager.switchFocus(stage, this@TextField)
        cursorPosition = 0
        selectionStart = 0
        //make sure textOffset was updated, prevent issue when there was long text selected and it was changed to short text
//and field was focused. Without it textOffset would stay at max value and only one last letter will be visible in field
        calculateOffsets()
        if (stage != null) stage.keyboardFocus = this@TextField
        onscreenKeyboard.show(true)
    }

    override fun focusLost() {}

    override fun focusGained() {}

    /** @return May be null.
     */
    private fun findNextTextField(actors: ArrayList<Actor>, best: TextField?, bestCoords: IVec2, currentCoords: IVec2,
                                  up: Boolean): TextField? {
        var best = best
        var i = 0
        val n = actors.size
        while (i < n) {
            val actor = actors[i]
            if (actor is TextField) {
                if (actor === this) {
                    i++
                    continue
                }
                if (actor.isDisabled || !actor.focusTraversal || !actor.ancestorsVisible()) {
                    i++
                    continue
                }
                val actorCoords = actor.parent!!.localToStageCoordinates(tmp3.set(actor.x, actor.y))
                val below = (actorCoords.y != currentCoords.y && actorCoords.y < currentCoords.y).xor(up)
                val right = (actorCoords.y == currentCoords.y && actorCoords.x > currentCoords.x).xor(up)
                if (!below && !right) {
                    i++
                    continue
                }
                var better = (best == null || actorCoords.y != bestCoords.y && actorCoords.y > bestCoords.y).xor(up)
                if (!better) better = (actorCoords.y == bestCoords.y && actorCoords.x < bestCoords.x).xor(up)
                if (better) {
                    best = actor
                    bestCoords.set(actorCoords)
                }
            } else if (actor is Group) best = findNextTextField(actor.children, best, bestCoords, currentCoords, up)
            i++
        }
        return best
    }

    /** @param str If null, "" is used.
     */
    fun appendText(str: String?) {
        var str = str
        if (str == null) str = ""
        clearSelection()
        cursor = textInternal.length
        paste(str, programmaticChangeEvents)
    }

    /** @param oldText May be null.
     * @return True if the text was changed.
     */
    fun changeText(oldText: String, newText: String): Boolean {
        if (newText == oldText) return false
        textInternal = newText
        val changeEvent = Event(EventType.Change)
        val cancelled = fire(changeEvent)
        textInternal = if (cancelled) oldText else newText
        return !cancelled
    }

    val selection: String
        get() = if (hasSelection) textInternal.substring(min(selectionStart, cursor), max(selectionStart, cursor)) else ""

    /** Sets the selected text.  */
    open fun setSelection(selectionStart: Int, selectionEnd: Int) {
        var selectionStart = selectionStart
        var selectionEnd = selectionEnd
        require(selectionStart >= 0) { "selectionStart must be >= 0" }
        require(selectionEnd >= 0) { "selectionEnd must be >= 0" }
        selectionStart = min(textInternal.length, selectionStart)
        selectionEnd = min(textInternal.length, selectionEnd)
        if (selectionEnd == selectionStart) {
            clearSelection()
            return
        }
        if (selectionEnd < selectionStart) {
            val temp = selectionEnd
            selectionEnd = selectionStart
            selectionStart = temp
        }
        hasSelection = true
        this.selectionStart = selectionStart
        cursor = selectionEnd
    }

    fun selectAll() {
        setSelection(0, textInternal.length)
    }

    fun clearSelection() {
        hasSelection = false
    }

    /** Sets the cursor position and clears any selection.  */
    var cursorPosition: Int
        get() = cursor
        set(cursorPosition) {
            require(cursorPosition >= 0) { "cursorPosition must be >= 0" }
            clearSelection()
            cursor = min(cursorPosition, textInternal.length)
        }

    override val prefWidth: Float
        get() = 150f

    override val prefHeight: Float
        get() {
            var topAndBottom = 0f
            var minHeight = 0f
            val background = style.background
            if (background != null) {
                topAndBottom = max(topAndBottom, background.bottomHeight + background.topHeight)
                minHeight = max(minHeight, background.minHeight)
            }
            if (style.focusedBackground != null) {
                topAndBottom = max(topAndBottom,
                        style.focusedBackground!!.bottomHeight + style.focusedBackground!!.topHeight)
                minHeight = max(minHeight, style.focusedBackground!!.minHeight)
            }
            if (style.disabledBackground != null) {
                topAndBottom = max(topAndBottom,
                        style.disabledBackground!!.bottomHeight + style.disabledBackground!!.topHeight)
                minHeight = max(minHeight, style.disabledBackground!!.minHeight)
            }
            return max(topAndBottom + textHeight, minHeight)
        }

    /** Sets the password character for the text field. The character must be present in the [BitmapFont]. Default is 149
     * (bullet).  */
    fun setPasswordCharacter(passwordCharacter: Char) {
        this.passwordCharacter = passwordCharacter
        if (passwordMode) updateDisplayText()
    }

    protected open fun moveCursor(forward: Boolean, jump: Boolean) {
        val limit = if (forward) textInternal.length else 0
        while ((if (forward) ++cursor < limit else --cursor > limit) && jump) {
            break
        }
    }

    fun onChanged(call: (newValue: String) -> Unit): ChangeListener {
        val listener = object : ChangeListener {
            override fun changed(event: Event, actor: Actor) {
                call(text)
            }
        }
        addListener(listener)
        return listener
    }

    /** Interface for listening to typed characters.
     * @author mzechner
     */
    interface TextFieldListener {
        fun keyTyped(textField: TextField?, c: Char)
    }

    /** Interface for filtering characters entered into the text field.
     * @author mzechner
     */
    interface TextFieldFilter {
        fun acceptChar(textField: TextField?, c: Char): Boolean
        class DigitsOnlyFilter : TextFieldFilter {
            override fun acceptChar(textField: TextField?, c: Char): Boolean {
                return c in '0'..'9'
            }
        }
    }

    /** An interface for onscreen keyboards. Can invoke the default keyboard or render your own keyboard!
     * @author mzechner
     */
    interface OnscreenKeyboard {
        fun show(visible: Boolean)
    }

    /** The default [OnscreenKeyboard] used by all [TextField] instances. Just uses
     * [Input.setOnscreenKeyboardVisible] as appropriate. Might overlap your actual rendering, so use with care!
     * @author mzechner
     */
    class DefaultOnscreenKeyboard : OnscreenKeyboard {
        override fun show(visible: Boolean) {
            //Gdx.input.setOnscreenKeyboardVisible(visible)
        }
    }

    /** Basic input listener for the text field  */
    open inner class TextFieldClickListener : ClickListener() {
        override fun clicked(event: InputEvent, x: Float, y: Float) {
            val count = tapCount % 4
            if (count == 0) clearSelection()
//            if (count == 2) {
//                val array = wordUnderCursor(x)
//                setSelection(array[0], array[1])
//            }
            if (count == 3) selectAll()
        }

        override fun touchDown(event: InputEvent, x: Float, y: Float, pointer: Int, button: Int): Boolean {
            if (!super.touchDown(event, x, y, pointer, button)) return false
            if (pointer == 0 && button != 0) return false
            if (isDisabled) return true
            setCursorPosition(x, y)
            selectionStart = cursor
            val stage = hud
            if (stage != null) stage.keyboardFocus = this@TextField
            onscreenKeyboard.show(true)
            hasSelection = true
            return true
        }

        override fun touchDragged(event: InputEvent, x: Float, y: Float, pointer: Int) {
            super.touchDragged(event, x, y, pointer)
            setCursorPosition(x, y)
        }

        override fun touchUp(event: InputEvent, x: Float, y: Float, pointer: Int, button: Int) {
            if (selectionStart == cursor) hasSelection = false
            super.touchUp(event, x, y, pointer, button)
        }

        protected open fun setCursorPosition(x: Float, y: Float) {
            cursor = letterUnderCursor(x)
            isCursorOn = focused
        }

        protected open fun goHome(jump: Boolean) {
            cursor = 0
        }

        protected open fun goEnd(jump: Boolean) {
            cursor = textInternal.length
        }

        override fun keyDown(event: InputEvent, keycode: Int): Boolean {
            if (isDisabled) return false
            isCursorOn = focused
            if (!hasKeyboardFocus()) return false
            var repeat = false
            val ctrl = KEY.ctrlPressed
            val jump = ctrl && !passwordMode
            var handled = true
            if (ctrl) {
                when (keycode) {
                    KEY.V -> {
                        //paste(clipboard.contents, true)
                        repeat = true
                    }
                    KEY.C, KEY.INSERT -> {
                        copy()
                        return true
                    }
                    KEY.X -> {
                        cut(true)
                        return true
                    }
                    KEY.A -> {
                        selectAll()
                        return true
                    }
                    KEY.Z -> {
                        val oldText = textInternal
                        text = undoText!!
                        undoText = oldText
                        updateDisplayText()
                        return true
                    }
                    else -> handled = false
                }
            }
            if (KEY.shiftPressed) {
                when (keycode) {
                    //KB.INSERT -> paste(clipboard.contents, true)
                    KEY.FORWARD_DEL -> cut(true)
                    KEY.LEFT -> {
                        val temp = cursor
                        moveCursor(false, jump)
                        repeat = true
                        handled = true
                        if (!hasSelection) {
                            selectionStart = temp
                            hasSelection = true
                        }
                    }
                    KEY.RIGHT -> {
                        val temp = cursor
                        moveCursor(true, jump)
                        repeat = true
                        handled = true
                        if (!hasSelection) {
                            selectionStart = temp
                            hasSelection = true
                        }
                    }
                    KEY.HOME -> {
                        val temp = cursor
                        goHome(jump)
                        handled = true
                        if (!hasSelection) {
                            selectionStart = temp
                            hasSelection = true
                        }
                    }
                    KEY.END -> {
                        val temp = cursor
                        goEnd(jump)
                        handled = true
                        if (!hasSelection) {
                            selectionStart = temp
                            hasSelection = true
                        }
                    }
                }
            } else { // Cursor movement or other keys (kills selection).
                when (keycode) {
                    KEY.LEFT -> {
                        moveCursor(false, jump)
                        clearSelection()
                        repeat = true
                        handled = true
                    }
                    KEY.RIGHT -> {
                        moveCursor(true, jump)
                        clearSelection()
                        repeat = true
                        handled = true
                    }
                    KEY.HOME -> {
                        goHome(jump)
                        clearSelection()
                        handled = true
                    }
                    KEY.END -> {
                        goEnd(jump)
                        clearSelection()
                        handled = true
                    }
                }
            }
            cursor = max(0, min(cursor, textInternal.length))
            //if (repeat) scheduleKeyRepeatTask(keycode)
            return handled
        }

        override fun keyUp(event: InputEvent, keycode: Int): Boolean {
            if (isDisabled) return false
            return true
        }

        override fun keyTyped(event: InputEvent, character: Char): Boolean {
            if (isDisabled) return false
            if (isReadOnly) return false
            when (character) {
                BACKSPACE, TAB, ENTER_ANDROID, ENTER_DESKTOP -> {
                }
                else -> if (character.toInt() < 32) return false
            }
            if (!hasKeyboardFocus()) return false
            //if (UIUtils.isMac && KB.isKeyPressed(KB.SYM)) return true
            if ((character == TAB || character == ENTER_ANDROID) && focusTraversal) {
                next(KEY.shiftPressed)
            } else {
                val delete = character == DELETE
                val backspace = character == BACKSPACE
                val enter = character == ENTER_DESKTOP || character == ENTER_ANDROID
                val add = if (enter) writeEnters else !onlyFontChars || style.font.hasGlyph(character)
                val remove = backspace || delete
                if (add || remove) {
                    val oldText = textInternal
                    val oldCursor = cursor
                    if (remove) {
                        if (hasSelection) cursor = delete(false) else {
                            if (backspace && cursor > 0) {
                                textInternal = textInternal.substring(0, cursor - 1) + textInternal.substring(cursor--)
                                renderOffset = 0f
                            }
                            if (delete && cursor < textInternal.length) {
                                textInternal = textInternal.substring(0, cursor) + textInternal.substring(cursor + 1)
                            }
                        }
                    }
                    if (add && !remove) { // Character may be added to the text.
                        if (!enter && textFieldFilter != null && !textFieldFilter!!.acceptChar(this@TextField, character)) return true
                        if (!withinMaxLength(textInternal.length)) return true
                        if (hasSelection) cursor = delete(false)
                        val insertion = if (enter) "\n" else character.toString()
                        textInternal = insert(cursor++, insertion, textInternal)
                    }
                    val tempUndoText = undoText
                    if (changeText(oldText, textInternal)) {
                        val time = APP.time
                        if (time - 750 > lastChangeTime) undoText = oldText
                        lastChangeTime = time
                    } else cursor = oldCursor
                    updateDisplayText()
                }
            }
            listener?.keyTyped(this@TextField, character)
            return true
        }
    }

    companion object {
        private const val BACKSPACE = 8.toChar()
        protected const val ENTER_DESKTOP = '\r'
        protected const val ENTER_ANDROID = '\n'
        private const val TAB = '\t'
        private const val DELETE = 127.toChar()
        private const val BULLET = 149.toChar()
        private val tmp1 = Vec2()
        private val tmp2 = Vec2()
        private val tmp3 = Vec2()
    }

    init {
        this.style = style

        addListener(clickListener)
        addListener(createInputListener().also { defaultInputListener = it })

        setSize(prefWidth, prefHeight)

        updateDisplayText()
    }
}
